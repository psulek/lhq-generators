#!/usr/bin/env node

import path from 'node:path';
import { Command } from '@commander-js/extra-typings';
import { createColors } from 'picocolors'
import fse from 'fs-extra';
import { glob } from 'glob';

type Colors = ReturnType<typeof createColors>;


import {
    Duration, Generator, GeneratorHostDataKeys,
    generatorUtils, isNullOrEmpty, jsonParseOrDefault,
    HostEnvironment, objCount,
    getLibraryVersion, namespaceUtils, fileUtils,
    detectFormatting, ModelUtils
} from './index';

import type { GeneratedFile, LhqModel, GeneratorInitialization, FileInfo, ReadFileInfoOptions, FormattingOptions } from './index'

const fileHeader = `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool - Localization HQ Editor.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------`;

let pc: Colors = createColors();

const init_cwd = process.env.INIT_CWD!;
const npm_script_file = path.join(init_cwd, 'node_modules');
const is_npm_script = __dirname.startsWith(npm_script_file);
const cwd = is_npm_script ? __dirname : process.cwd();


const cliToolHeader = (): string => pc.bold(`LHQ Code Template Generator ${pc.gray(`(${getLibraryVersion()})`)}\n`);

class HostEnvironmentCli extends HostEnvironment {
    public pathCombine(path1: string, path2: string): string {
        return path.join(path1, path2);
    }
}

async function safeReadFile(fileName: string): Promise<string> {
    return fileUtils.safeReadFile(fileName, fse.pathExists, fse.readFile);
}

async function readFileInfo(inputPath: string, options?: ReadFileInfoOptions): Promise<FileInfo> {
    return fileUtils.readFileInfo(inputPath, path, fse.pathExists, fse.readFile, options);
}

async function validateLhqModelFile(lhqFileName: string, verbose: boolean): Promise<void> {
    lhqFileName = path.resolve(lhqFileName);

    if (!await fse.pathExists(lhqFileName)) {
        throw new Error(`LHQ model file '${lhqFileName}' not found.`);
    }

    const lhqFile = await safeReadFile(lhqFileName);
    const model = jsonParseOrDefault<LhqModel>(lhqFile, {} as LhqModel, true);
    const valid = generatorUtils.validateLhqModel(model);
    const resultStr = valid.success ? pc.greenBright('VALID:') : pc.redBright('INVALID:');
    const fileStr = pc.cyanBright(lhqFileName);
    const validStr = valid.success
        ? `File ${fileStr} has valid schema.`
        : `File '${fileStr}' has invalid schema.\n${pc.redBright(valid.error ?? '')}`;

    console.log(`${pc.bold(resultStr)} ${validStr}`);
}

async function saveLhqModelFile(model: LhqModel, fileName: string, fileContent?: string): Promise<void> {
    fileContent = fileContent ?? await safeReadFile(fileName);
    const options = detectFormatting(fileContent) ?? {} as FormattingOptions;
    const json = ModelUtils.serializeModel(model, options);
    await fse.writeFile(fileName, json, { encoding: 'utf-8' });
}

async function generateFromLhq(hbsTemplatesDir: string, lhqFileName: string, csProjectFileName: string, outputDir: string,
    hostData: Record<string, unknown>, verbose: boolean, fixNamespace: boolean): Promise<void> {

    lhqFileName = path.resolve(lhqFileName);

    if (!(await fse.pathExists(lhqFileName))) {
        throw new Error(`LHQ model file '${lhqFileName}' not found.`);
    }

    if (!isNullOrEmpty(csProjectFileName) && !(await fse.pathExists(csProjectFileName))) {
        throw new Error(`C# project file '${csProjectFileName}' not found.`);
    }

    const metadataFile = path.join(hbsTemplatesDir, 'metadata.json');
    const metadataContent = await fse.readFile(metadataFile, { encoding: 'utf-8' });
    const validateResult = generatorUtils.validateTemplateMetadata(metadataContent);
    if (!validateResult.success) {
        throw new Error(`Validation of ${metadataFile} failed: ${validateResult.error}`);
    }

    const generatorInit: GeneratorInitialization = {
        hbsTemplates: {},
        templatesMetadata: validateResult.metadata!,
        hostEnvironment: new HostEnvironmentCli()
    };

    if (!(await fse.pathExists(hbsTemplatesDir))) {
        throw new Error(`LHQ templates directory '${hbsTemplatesDir}' not found.`);
    }

    const hbsFiles = await glob('*.hbs', { cwd: hbsTemplatesDir, nodir: true });

    if (hbsFiles.length === 0) {
        throw new Error(`LHQ templates directory '${hbsTemplatesDir}' is empty.`);
    }

    let cmdDataStr = '-';
    const hostDataCount = objCount(hostData);
    if (hostDataCount > 0) {
        const max = verbose ? hostDataCount : 2;
        cmdDataStr = '\n' + Object.entries(hostData)
            .map(([key, value]) => `   ${key}=${String(value)}`)
            .slice(0, max)
            .join('\n');

        if (hostDataCount > max) {
            cmdDataStr += `\n   ... (${hostDataCount - max} more data)`;
        }
    }

    const templateLoaders = hbsFiles.map(async (hbsFile) => {
        const templateId = path.basename(hbsFile, path.extname(hbsFile));
        const fullFilePath = path.join(hbsTemplatesDir, hbsFile);
        generatorInit.hbsTemplates[templateId] = await safeReadFile(fullFilePath);
    });

    await Promise.all(templateLoaders);

    const lhqFileContent = await safeReadFile(lhqFileName);
    let model: LhqModel = undefined!;
    try {
        model = JSON.parse(lhqFileContent) as LhqModel;
    } catch (e) {
        throw new Error(`Error parsing LHQ model file '${lhqFileName}': ${(e as Error).message}`);
    }

    Generator.initialize(generatorInit);

    if (fixNamespace) {
        model = await fixNamespaceForLhqModel(csProjectFileName, lhqFileName, lhqFileContent, model);
    }

    if (isNullOrEmpty(hostData[GeneratorHostDataKeys.fileHeader])) {
        hostData[GeneratorHostDataKeys.fileHeader] = fileHeader;
    }

    console.log(`Starting code generating for:\n` +
        `- lhq model file: ${pc.yellow(lhqFileName)}
- out dir: ${outputDir}
- data: ${cmdDataStr}\n`);

    //- c# project file: ${hasCsProj ? csProjectFileName : '-'} ${hasCsProj ? `(${csProjFound ? 'auto found' : 'cmd'})` : ''}

    const generator = new Generator();

    const duration = Duration.start();
    const result = generator.generate(lhqFileName, model, hostData);
    const genFileCount = result.generatedFiles.length;
    console.log(`Generated ${pc.blueBright(genFileCount)} files in ${pc.blueBright(duration.elapsedTime)}.\n`);


    const output = path.resolve(outputDir);
    console.log(`Output directory: ${output}`);
    const saveFilesMap = result.generatedFiles.map(async (file) => {
        await saveGenFile(file, output);
        console.log(`Saved file ${file.fileName}.`);
    });

    await Promise.all(saveFilesMap);
}

async function fixNamespaceForLhqModel(csProjectFileName: string, lhqFileName: string, lhqFileContent?: string, model?: LhqModel): Promise<LhqModel> {
    lhqFileContent = lhqFileContent ?? await safeReadFile(lhqFileName);
    model = model ?? JSON.parse(lhqFileContent) as LhqModel;

    const namespace = await findNamespaceFromCsProj(csProjectFileName, lhqFileName);
    const rootModel = ModelUtils.createRootElement(model);
    const templateId = rootModel.codeGenerator?.templateId ?? '';
    if (!isNullOrEmpty(templateId)) {
        throw new Error('Not implemented yet: fixNamespaceForLhqModel method !');
        // const csharpSettings = rootModel.codeGenerator?.settings?.childs?.find(x => x.name === 'CSharp');
        // if (csharpSettings) {
        //     const currentNamespace = csharpSettings.attrs?.['Namespace'] ?? '';
        //     if (isNullOrEmpty(currentNamespace)) {
        //         csharpSettings.attrs!['Namespace'] = namespace;
        //         model = ModelUtils.rootElementToModel(rootModel);
        //         await saveLhqModelFile(model, lhqFileName, lhqFileContent);
        //         console.log(`Namespace '${pc.blueBright(namespace)}' was updated in 'CSharp' settings in file '${pc.yellow(lhqFileName)}'.`);
        //     }
        // }
    }

    return model;
}

async function findNamespaceFromCsProj(csProjectFileName: string, lhqFileName: string): Promise<string> {
    const lhqFile = await readFileInfo(lhqFileName, { encoding: 'utf-8' });

    const csProjectFiles: FileInfo[] = [];
    if (!isNullOrEmpty(csProjectFileName)) {
        const csProjectFile = await readFileInfo(csProjectFileName, { encoding: 'utf-8', loadContent: true });
        if (csProjectFile.exist) {
            csProjectFiles.push(csProjectFile);
        }
    } else {
        const dir = lhqFile.dirname;
        const csProjectFilesFound = await glob('*.csproj', { cwd: dir, nodir: true });
        for (const csProj of csProjectFilesFound) {
            const csProjPath = path.join(dir, csProj);
            const csProjFile = await readFileInfo(csProjPath, { encoding: 'utf-8', loadContent: true });
            if (csProjFile.exist) {
                csProjectFiles.push(csProjFile);
            }
        }
    }

    const namespaceInfo = namespaceUtils.findNamespaceForModel(lhqFile, csProjectFiles);
    return namespaceInfo?.namespace ?? '';
}

async function saveGenFile(generatedFile: GeneratedFile, outputPath?: string): Promise<void> {
    const content = generatorUtils.getGeneratedFileContent(generatedFile, true);
    const bom = generatedFile.bom ? '\uFEFF' : '';
    const encodedText = Buffer.from(bom + content, 'utf8');

    const fileName = !outputPath ? generatedFile.fileName : path.join(outputPath, generatedFile.fileName);
    const dir = path.dirname(fileName);

    await fse.ensureDir(dir);
    await fse.writeFile(fileName, encodedText, { encoding: 'utf8' });
}

// async function tempRun() {
//     const dir = path.join(process.cwd(), 'tests/data/templates/');
//     const lhqFiles = await glob('**/*.lhq', { cwd: dir, nodir: true });
//     const fixWorks = lhqFiles.map((lhqFile) => fixNamespaceForLhqModel('', path.join(dir, lhqFile)));
//     await Promise.all(fixWorks);
// }

// eslint-disable-next-line @typescript-eslint/no-floating-promises
(async () => {
    try {

        const args = process.argv.slice(2);
        const isVersion = args.length === 1 && args[0] === '-v' || args[0] === '--version';
        const isCmdHelp = args.length > 1 && args[0] === 'help';
        const cmdHelpName = isCmdHelp ? args[1] : '';

        const noColorIdx = args.findIndex(a => ['--no-colors', '--no-color'].includes(a));
        const noColors = noColorIdx > -1;
        if (noColorIdx > -1) {
            args.splice(noColorIdx, 1);
        }

        const helpIdx = args.findIndex(a => ['--help', '-h', '/?'].includes(a));
        const isHelp = helpIdx > -1;
        if (helpIdx > -1) {
            args.splice(helpIdx, 1);
        }

        const lhqfile = args.length > 0 ? args.shift() ?? '' : '';

        if (noColors) {
            process.env['NO_COLOR'] = noColors ? '1' : '';
        }
        pc = createColors(noColors === false);

        const cliToolName = 'lhqcmd';
        const cliToolNameColor = pc.cyan(cliToolName);
        const cliCommand = (str: string) => pc.blueBright(str);
        const cliItalic = (str: string) => pc.italic(str);

        const hint = `* when [command] is omitted, the default command is: ${cliCommand('generate')}`;

        const program = new Command()
            .name(cliToolName)
            .usage('<lhqfile> [command] [options]')
            .description('Run various actions against LHQ files')
            //.argument('<lhqfile>', 'The LHQ project file *.lhq (e.g., Strings.lhq)')
            .version(getLibraryVersion(), '-v, --version', 'output the version number')
            .option('--verbose', 'enable verbose output', false)
            .option('--no-color', 'disable color output')
            .addHelpText('beforeAll', cliToolHeader())
            .addHelpText(
                'after',
                `
${pc.bold('Examples:')}
  ${cliToolNameColor} ${pc.yellow('Strings.lhq')} ${cliCommand('generate')} --project MyProject.csproj --out ./output --data namespace=Namespace1
  ${cliToolNameColor} ${pc.yellow('Strings.lhq')} -o ./output
  ${cliToolNameColor} ${pc.yellow('Strings.lhq')} ${cliCommand('validate')}

  ${cliItalic(hint)}
`);

        program.configureHelp({
            styleTitle: (str) => pc.bold(str),
            styleCommandText: (str) => pc.cyan(str),
            styleCommandDescription: (str) => pc.magentaBright(str),
            styleDescriptionText: (str) => pc.italic(str),
            styleOptionText: (str) => pc.gray(str),
            styleArgumentText: (str) => pc.yellow(str),
            styleSubcommandText: (str) => pc.blueBright(str),
        });

        const generateCommand = new Command('generate')
            .description('Run template generator associated with LHQ file')
            //.usage('<lhqfile>')
            //.usage('<lhqfile> [options]')
            //.usage('<lhqfile> generate [options]')
            //.addHelpText('before', '<lhqfile> Q#1')
            .option('-p, --project <project>', 'The C# project file *.csproj (e.g., MyProject.csproj)')
            .option('-o, --out <out>', 'The output directory', '.')
            .option('--fixns', 'Fix missing namespace for C# templates', false)
            .option('-d, --data <data...>', 'Key-value pairs for host data (e.g., key=value)')
            .addHelpText(
                'after',
                `
${pc.bold('Examples:')}
  ${cliToolNameColor} ${pc.yellow('Strings.lhq')} ${cliCommand('generate')} --project MyProject.csproj --out ./output --data namespace=Namespace1
`)
            .action(async (options) => {
                let hostData: Record<string, string>;
                const verbose = program.opts().verbose ?? false;

                if (options.data) {
                    hostData = options.data.reduce<{ [key: string]: string }>((acc, item) => {
                        const [key, value] = item.split('=');
                        acc[key] = value;
                        return acc;
                    }, {});
                } else {
                    hostData = {};
                }

                const fixNamespace = options.fixns ?? false;

                const hbsTemplatesDir = path.join(cwd, 'hbs');
                await generateFromLhq(hbsTemplatesDir, lhqfile, options.project ?? '', options.out ?? '.', hostData, verbose, fixNamespace);
            });

        const validateCommand = new Command('validate')
            .description('Validate the input LHQ file')
            //.usage('<lhqfile>')
            .addHelpText(
                'after',
                `
${pc.bold('Examples:')}
  ${cliToolNameColor} ${pc.yellow('Strings.lhq')} ${cliCommand('validate')}
`)
            .action(async () => {
                const verbose = program.opts().verbose ?? false;
                await validateLhqModelFile(lhqfile, verbose);
            });


        program.addCommand(generateCommand);
        program.addCommand(validateCommand);

        //await tempRun();


        if (isCmdHelp && !isNullOrEmpty(cmdHelpName)) {
            if (cmdHelpName === 'generate') {
                // program.usage('');
                // generateCommand.usage('<lhqfile> a@1');
                generateCommand.outputHelp();
            } else if (cmdHelpName === 'validate') {
                validateCommand.outputHelp();
            }
            process.exit(0);
        }

        let rootCmd = 'generate';
        if (args.length > 0 && ['generate', 'validate'].includes(args[0])) {
            rootCmd = args.shift()!;
        }

        if (isHelp || (args.length === 0 && isNullOrEmpty(lhqfile))) {
            program.outputHelp();
            process.exit(0);
        }

        if (isVersion) {
            await program.parseAsync(['--version'], { from: 'user' });
        } else {
            console.log(cliToolHeader());
            await program.parseAsync([rootCmd, ...args], { from: 'user' });
        }
    } catch (error) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
        console.error(pc.redBright((error as any).toString()));
    }
})();